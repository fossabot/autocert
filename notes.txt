https://tools.ietf.org/html/rfc8555
https://github.com/letsencrypt/boulder/blob/master/docs/acme-divergences.md

https://github.com/golang/crypto/tree/master/acme/autocert
https://github.com/farrepa/django-autocert/tree/develop/autocert
https://github.com/diafygi/acme-tiny
https://github.com/caddyserver/certmagic
https://github.com/mholt/acmez

https://docs.python.org/3/library/socket.html
https://docs.python.org/3/library/ssl.html

https://github.com/dehydrated-io/dehydrated/blob/master/docs/tls-alpn.md
https://fossies.org/linux/ansible/lib/ansible/modules/crypto/acme/acme_challenge_cert_helper.py
https://sites.lafayette.edu/fultonc/2019/02/03/using-tls-alpn-01-on-a-raspberry-pi/


The game plan:
--------------
if not exists(cache_dir):
    create cache_dir

fetch directory

if exists(acct):
    load pkey from cache
    lookup acct by pkey
else:
    generate pkey
    save pkey to cache
    create acct

for cert in certs:
    if not exists(cert):
        order + challenge + poll cert
        save cert to cache
    else:
        load cert from cache
        check renew now

    schedule renew (30 days remaining +/- 30 mins jitter)


renew
-----
if remaining > 30 days:
    sleep(remaining - 30 days)
else:
    order + challenge + poll cert
    save cert to cache
    call s.context.load_cert_chain()

keep track of the SSLContext (or just the SSLSocket)
new clients from accept() should now get the new stuff
old ones will still have the "old" cert but that's fine (still valid)
